<div id="app">
  <h1>ASYNCHRONOUS JAVASCRIPT</h1>
  <ul>
    <li>
      JavaScript is a
      <mark><em>synchronous, blocking, single threaded</em></mark> language.
    </li>
    <li>
      <strong>Synchronous:</strong> If we have two functions which log messages
      to the console, code executes top down, with only one line executing at
      any given time.
    </li>
    <li>
      <strong>Blocking</strong>:
      <ol>
        <li>
          No matter how long a previous process takes, the subsequent processes
          won't kick off until the former is completed.
        </li>
        <li>
          If function A had to execute an intensive chunk of code, JavaScript
          has to finish that without moving on to function B. Even if that code
          takes 10 seconds or 1 minute.
        </li>
        <li>
          Web app runs in a browser and it executes an intensive chunk of code
          without returning control to the browser, the browser can appear to be
          frozen.
        </li>
      </ol>
    </li>
    <li>
      <h3>Single-threaded</h3>
      <ol>
        <li>
          A thread is simply a process that your JavaScript program can use to
          run a task.
        </li>
        <li>Each thread can only do one task at a time.</li>
        <li>
          JavaScript has just the one thread called the main thread for
          executing any code.
        </li>
      </ol>
    </li>
    <li>
      <h3>Problem with synchronous, blocking, single-threaded model of JavaScript.</h3>
      <ol>
        <li style="background-color:lightgray">
          <pre><code>
  let response = fetchDataFromDB('endpoint')</br>
  displayDataFromDB(response);</code>               
          </pre></li>
        <li><em>fetchDataFromDB('endpoint') could take 1 second or even more</em></li>
        <li>During that time, we can't run any further code.</li>
        <li>JavaScript, if it simply proceeds to the next line without waiting, we have an error because data is not what we expect it to be.</li>
      </ol>      
    </li>
    <li>
      <h3>How to achieve Async JavaScript?</h3>
      <ol>
        <li>JavaScript is not enough.</li>
        <li>We need new pieces which are outside of JavaScript to help us write asynchronous code which is where web browsers come into play.</li>
        <li>Web browsers define functions and APIs that allow us to register functions that should not be exceeded synchronously, and should instead be invoked asynchronously when some kind of event occurs.</li>
        <li>For exmaple: that could be the passage of time ( setTimeout or setInterval), the user's interaction with the mouse (addEventListener), or the arrival of data over the network (callbacks, Promises, async-await).</li>
        <li>You can let your code do several things at the same time without stopping or blocking your main thread.</li>
      </ol>
    </li>
    <li>
    <h3>Timeouts & Intervals</h3>    
    <p>The JavaScript has traditional methods available to run code asynchronously:</p>
  <ul>
    <li>after a set time period elapsed</li>
    <li>or at regular intervals of time</li>
    <li><mark><strong>setTimeout()</strong></mark> The <em>setTimeout()</em> function executes a particular block of code once after a specified time has elapsed.</li>
    <li>Syntax: <pre><code style="background-color:lightyellow;">setTimeout(function, duration, param1, param2, ...)</code></pre></li>
    <li>The first parameter is a function to run, or a reference to a function defined elsewhere.</li>
    <li>The second parameter is a number representing the duration in milliseconds to wait before executing the code.</li>
    <li>After the second parameter, you can pass in zero or more values that represent any parameters you want to pass to the function when it is run.</li>
    <li>To clear a timeout, you can use the <mark><code>clearTimeout()</code></mark> method passing in the identifier returned by setTimeout as a parameter.</li>
    <li>A more practical scenario is clearing timeouts when the component is unmounting to free up the resources and also prevent code from incorrectly executing on an unmounted compontnt.</li>
  </ul>  
  </li>
  </ul>

  <p>
  <a href="https://www.youtube.com/watch?v=exBgWAIeIeg">Asynchronous JavaScript Crash Course 2022 by Codevolution</a>
  </p>
</div>
